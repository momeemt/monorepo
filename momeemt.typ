#set text(font: "Hiragino Kaku Gothic ProN")
#set page(numbering: "1 / 1")

= 開発したいテーマ
私は拡張性を高く持つマークアップ言語であるBrackを開発したいと考えています。
このテーマは同日に提出された上野幹太さんと共同で進めているプロジェクトで、担当箇所を明確に切り分けています。
私はプラグインの実装とプロジェクト管理を中心に、彼はパーサとLanguage Serverの実装を担当します。
お互いの書類でBrackの概要と担当箇所のやりたいことについて説明します。

= Brackの概要
#include "brack-overview.typ"

= 方針
現在は、Brack自体が特定の問題を解決するのではなく、マークアップ言語を開発するための基盤としての方向で進めています。
文法が定まっており、一定のルールに基づいて変換・Language Serverやパッケージマネージャ、フォーマッタ、リンタなどの周辺ツールへの介入を行う言語基盤は新しいのではないかと思っています。
また、これはプログラミング言語ではなく、シンタックスの重要度があまり高くない、変換先に関心がある文章主体の軽量マークアップ言語だから成り立つのではないでしょうか。

JSXをはじめとする既存のWebコンポーネント資産を流用できるMDXや、言語機能が制限される代わりに変換前後どちらも可読性が高いMarkdownなどが既に持っている領域を奪うことは難しいです。
言語そのものの設計思想や性能もさながら、既に作られた関連ツールの資産が強いためです。
Brackは、今はまだ存在しない、マークアップ言語と関連ツールによって効率化できる領域を狙っています。
私個人が作ってみたいマークアップ言語は以下の通りです。

- ブログやtimesを記述する言語
  - 自分のブログをBrackで書いていることからも、最もdogfoodingしやすい対象だと思います
  - 特にMarkdownでは表現力が足りず、nodejs以外の環境ではMDXを利用することは困難なのでBrackは便利です
- スライドの作成
  - Markdownのスライド作成ツールとしてMarpがありますが、規定されたクラスを上手く使ってCSSでデザインする必要があり困難が発生することがあります
  - 直接PDF、共有可能なWebページ、あるいはスライドサービスのデータに変換することでよりシームレスに文書主体のスライドを作成できると思います
- レシピの記述言語
  - 料理が趣味なので、レシピを記述する言語があったら便利だと思います
  - 付随して、料理中の工程を（撮影や行動追跡で）記録してBrackに変換したり、買い物リストなどを作ったりすれば便利そうです
  - 栄養を計算して既に存在するレシピから選択できると健康になりそうです
  - 好みの変化がバージョン管理できると面白そうです
- 旅行計画を記述する言語
  - 旅行計画を記述する言語があれば便利だなと思います
  - 著名な観光地をリスト化したり、旅程を記述して現実的に不可能な旅程を静的に検査できそうです
  - 最終的にYahoo!の乗換案内のスクリーンショットとWebページ、あるいはLINEのアカウントから旅程を送信することを想定しています
- GPTを用いたテキスト記述言語
  - 文章を書く際にChatGPTを使うことは多いですが、文の構造を変形したり、箇条書きを文章に変換することはよくあります
  - そのようなプロンプトをコマンドとして扱ってスニペットで変換することでスムーズな執筆体験を提供できそうです
- プログラミング言語の実行環境が同梱された文書
  - Wasmとしてインタプリタを埋め込めば、実行環境が同梱された文書を作成できます

他にも、私個人には専門的な知識が存在しないために想像の範囲を超えませんが、以下のような領域で新たなマークアップ言語の開発が仕事を効率的にする可能性があると思っています。

- 法律文書の作成
  - 契約書などの法律文書を作成するための言語があれば、知識がなくても法的なルールに則って文書を作成できそうです
- 暗記帳の作成
  - 複雑な暗記項目を表現し、Ankiのデータに変換するなどが考えられます
- 計画書の作成
  - ざっくりとした計画をLLMの力を借りて分解していくのに便利かもしれません

= 経緯
以下に、これまでのBrackの経緯を示します。
Brackは2022年の夏に自分のブログを書くためのマークアップ言語として開発を始めました。
純粋な動機としては「自分で設計したマークアップ言語でブログを書けたら面白いかもしれない」程度のものでしたが、いくつかブログにとってMarkdownと比較して優位そうな点があり、開発を進めました。

軽量マークアップ言語はデータ記述の整合性を保ちつつ、ソースコードの可読性も意識して設計されていますが、変換後のコンテンツのみが重要で、かつユーザーにより多様な表現力が求められるブログ記事の記述にはMarkdownはあまり向かないと思いました。
既存の文法だけでは表現力が足りず、HTMLが混在するMarkdown文書を見たことはあるのではないでしょうか。
Markdownは標準的で明文化された仕様を持たないゆえに、運用されている方言が無数に存在しています。
後発でCommonmarkやGitHub Flavored Markdownなどが定められていますが、どれが本当のMarkdownかを知っている人は少ないと思います。本来は最初にHTML向けの文書変換器として作られたMarkdown.plがオリジナルですが、インデントの空白の個数の処理など細かい部分において明確な文法が定まっていません。
そのような現状を踏まえると、ブログを書くために必要なマークアップ言語は、特定の装飾に文法を対応させた言語ではなく、文法はコマンドと引数の解釈のみを規定し、装飾をユーザーが定義することで自由に拡張可能な言語なのではないかと思いました。

近年ではJSXを解釈できるMDXも登場して、Webフロントエンドとの相性の良さから急速に広まっています。
これはMarkdown自体の曖昧性を排除できているわけではないのと、実行環境がnodejsに縛られてしまうのでその点において新しい言語を考える価値がありそうです。

2022年当時は処理系の実装も、コマンドの定義もすべてNimで行っていました。
処理系の方はさておき、プラグインをコンパイル時に解決していたのが大きな誤りでした。
本来はユーザがソフトウェアのビルド後に新しい機能を導入するゆえに「プラグイン」なのだとは思いますが、動的に解決することで実行時エラーが発生する可能性が高まるので、それを嫌ってコンパイル時に必要なプラグインを全て揃えていました。
それを実現するためにプラグインの展開は全てNimのマクロで書かれており、可読性が悪くなった結果、開発が進まなくなりました。

2023年の12月、WebAssemblyのバイナリをプラグインとして使うアイデアを思いつき、実装を書き換えました。
すると、自分の慣れた言語でコマンドを動的に拡張できることの強力さに気が付きました。これまではBrackはブログのためのマークアップ言語だと思っていたのですが、文法が最小限でコマンドが定義できるので既存のエコシステムに乗っかって新しい、何か特定領域の文書執筆をサポートするマークアップ言語（便宜的に、ドメイン固有マークアップ言語と呼びます）を作るためのツールとして使えるのではないだろうかと思いました。ふとその考えと、Language Serverなどの言語のツールチェーンこそが最近の言語の流行の中心にあると思う、という話を友人にしたところ、プラグインがLanguage Serverなどのツールチェーンの実行にも介入できたら問題解決のツールを作るコストが大幅に減るね、という話になりました。
その後、先に述べたような目標になり、開発を進めています。

= サイボウズ・ラボユースで取り組みたいこと

== 言語設計
ラボユースに応募する最も大きな動機は言語設計について議論したいという点です。
これからBrackを実用的な言語にするためには、大量の文法要素、言語機能について、明確な理由の元に言語設計をする必要があると思います。
一方で私と上野は大学入学以降に言語処理系を学び始めたために全て自分たちで正しい決定を行えるとは思っていません。
外部の知見を持ったエンジニアの方と定期的に言語設計について議論することはBrackにとって非常に有用であるはずです。
以下に、具体的に迷っている言語機能を述べます。

=== コマンドの分類
当初はHTMLに変換する言語としてBrackを考えていたため、HTMLのインライン要素（`[]`）とブロック要素（`{}`）、マクロ（`<>`）に対して3種類の括弧列を割り当てました。
しかし、Brackは複数のバックエンド言語を想定していますから、HTMLのインライン要素とブロック要素という区別は適当ではないように感じています。
たとえば、スライドを出力するためにBrackを用いるならば`[]`と`{}`の意味論的な区別はあるのでしょうか。
一例として、通常のコマンド呼び出しを`[]`に統一して、エディタ上で実行されるスニペットコマンドを`{}`に割り当てるという案があります。

```
{std.list
  [std.list-elem hoge1],
  [std.list-elem hoge2],
  [std.list-elem hoge3],
}
```

仮にHTMLバックエンドであれば`std.list`は`ul`要素に、`std.list-elem`は`li`要素に変換されるでしょう。
しかしこれは冗長です。Markdownであれば以下のように記述できます。

```md
* hoge1
* hoge2
* hoge3
```

TeX/LaTeXの代替として関数型組版言語のSATySFiがありますが、LaTeXに対して執筆体験が非常に改善されているにも関わらずユーザ数はそれほど多くありません。
インストール手順にOCamlのパッケージマネージャであるduneが利用されている、ライブラリを書くのにduneの知識が必要である、具体的にはOCamlベースの文法によるコマンド定義などのSATySFi固有の難しさが、LaTeXを代替するところまでは行っていない1つの要因だと思います。
一方で近年急激にTypstが新たな組版言語として台頭しており、大学教員の間でも実用される機会が増えているようです。
TypstはRe:ViewやMarkdownを感じさせる軽量な文法を持ちながらも非常に導入が簡単な組版言語で、Language ServerやHot reloading serverを提供しており執筆体験も保証されています。
SATySFiはTypstよりも抽象化されており、特に自分でコマンドを定義したりライブラリを作るのであれば静的型付けにより安心して開発ができる素晴らしい言語だと感じますが、文書を書いてPDFを作りたいユーザはそこにコストを掛けるのを嫌がったのだと思います。
実際にこの申請書類もインストールの問題を避けるためにSATySFiではなくTypstで管理しています。

このように、言語の利用者は「環境構築」「執筆体験」「簡単に目的が達成できるか」などを重要視しており、言語的に厳密であるか、高速であるか、致命的なエラーが発生しないかなどは考慮されていないように思います。
Brackにおいては単純なコマンド呼び出しのみで構成されていることが重要なコンセプトの1つですが、リストやテーブルのように複雑な構造を取る場合には冗長になることがあります。
そこで、`{}`をエディタ上で特定の記法をBrackのコマンド呼び出し記法に変換するためのスニペットとして利用します。
具体的には、次のようなスニペットを、

```
{std.list
  - hoge1
  - hoge2
  - hoge3
}
```

次のようなコマンド呼び出しに変換するということです。

```
[std.unorder-list
  [std.- hoge1],
  [std.- hoge2],
  [std.- hoge3],
]
```

プログラムには書く側面と読む側面があります。
強力な表現力を持ち、抽象化されたプログラムは書きやすいですが読み下すのに時間がかかります。
他方、Go言語のようにフォーマッタや限定された文法によって誰が書いても同じようなプログラムに仕上がる設計にすることで読みやすさを担保する方針もあります。
Brackの「文法を単一のコマンド呼び出し構文に限定する」という方針は、大きく2つの理由から採用しています。

- パースしやすい・文法の複雑性を排除できる（読みやすさ）
- 拡張することを前提に置く

現在のBrackは読みやすさを重視した記法で、複雑なデータ構造（テーブルや入れ子のあるリスト）を表現するには書きにくいです。
もしスニペットを採用すれば、人間やパーサなどの読む側にとってはBrackのコマンド呼び出し構文で表現されているので読みやすさが担保され、書く側にとっては複雑な構文を平易な文法で代替できます。
ただし、スニペットを導入することに対して幾つかの不安もあります。

- プラグインの塩梅によってユーザが記法を理解するために新たな負担を受ける可能性があり、Brackの最小の文法と拡張による言語というコンセプトも壊れかねない
- スニペットで展開されたコードに対してエラーが発生すると執筆体験を損ねる
- 書いたコードが別のコードになって保存されることへの抵抗感

=== 制約
Brackはプラグインがあり、自由に拡張可能で、ある意味制約として持っているのはコマンド呼び出し構文のみです。
Markdownは表現力に乏しいですが、表現力に欠けているからこそ多くのプロジェクトのドキュメント文書として採用されている面もあります。
何でもできる言語は制御不能で恐怖感があり、出来ないことが明白であればあるほど気軽に使えます。
現在のBrackは制御不能な状態に近く、広く使ってもらうためには（現在は思いついていませんが）プラグイン周りへの適切な制約が必要になってくると思っています。

Brackを実用的な言語として作っていくために、ラボユースでメンターさんや他の参加者と議論しつつ、基本的にBrackが持つ言語機能とそれが提供する嬉しさ、制約を固めたいです。

== プラグイン
また、プラグインシステムの開発にも取り組みたいと考えています。
Brackの核は文法ではなくプラグインにあります。
プラグインはWebAssemblyのバイナリを指しており、Brack文書をパースすることにより得られるプラグイン名とコマンド名を元に、Wasmバイナリを呼び出します。
一見シンプルな仕組みですが、執筆体験と汎用性を維持するためには考慮するべきことが多くあります。

=== メタデータ
Wasmは静的に型付けがされますが、組み込み型としては整数型のみを持ちます。
実装に用いているExtismは何らかのルールによって構造体や文字列などをメモリ上に展開しているのですが、その影響でRustなどが本来持っている型の表現力による恩恵をそのまま受けることはできません。
具体的には、Extismはプラグイン関数に対して1つの引数のみを持つことを要請するため、複数のデータをやり取りしたい場合には構造体を用いることで、可変長引数を表現したい場合には`enum`を用いることで対処するしかありません。
しかし、こうなるとバイナリから関数がどのようなデータを要求しているのかを読み出すのは非常に困難です。
そこで、Brackの実装ではあらかじめプラグインを読み出した時点で以下の情報を得るための関数を連続して呼び出します。この情報を便宜的にメタデータと呼んでいます。

- (Brackにおける) コマンド名
- (Wasmバイナリにおける) 関数名
- 引数型
- 戻り値型

メタデータを初期化時に得ることで、Wasmを詳細にパースする必要がなくプラグインシステムを実現できます。

=== セキュリティ
Wasmによるプラグインを扱うにはセキュリティリスクに十分注意する必要があります。
BrackのプラグインはWebAssembly System Interface（以下、WASI）を有効にしていますが、サンドボックスの制御を怠れば
文書に潜んだ悪意のあるプラグインによって執筆者の計算機環境に被害を出す可能性があります。
プラグインシステムを設計する際には、単にWasmを使うだけでなく本質的な構造を理解して対策しなければなりません。

=== フック
現行のBrackのプラグインはバックエンド言語としてHTML以外も選択できますが、テキストファイル以外への変換も考えています。
具体的にはBrackでスライドを作りたい場合を考えます。
プラグインシステムが可能なのは基本的にテキストを別のテキストに置換する、あるいはASTを別のASTに置換することです。
したがってそのままでは画像やPDFのフォーマットを取ることが想定されるスライドの作成は難しいように思えます。

ここで、フックを導入したいと考えています。
フックはBrackのASTから変換されたJSON（などのデータ）を入力に何らかの操作を行うプログラムのことです。
Brackのファイルから構築されたデータを元に、任意のプログラムを実行します。

#align(center)[
  #image("./figure1.jpeg", width: 60%)
]

一方でフックにも問題点があります。

- 現状のプラグインシステムは非常に分散的です
  - 中央集権的なプラグインレジストリが存在しません
  - プラグイン同士の依存関係がないので、独立して動作します
- 一方でフックを導入すると、特定のプラグインが動作しないと、動かしたいプラグインが動作しなくなるリスクがあります
  - フックはBrackを単にデータに変換してから任意のプログラムを実行するので、特定のバックエンドへのコマンドをすべて処理できる大きなディスパッチ関数が1つ必要になります
  - 仮にプラグイン内にデータを処理する関数を定義してディスパッチャーが呼び出すこともできますが、結局のところ依存関係が生まれます

提案したフックはBrackをバイナリに変換する最も素直な方法であり、導入するかどうかも含めて、より適切な抽象化がないかを検討する必要があります。

=== 型付け
Brackには現状型システムがありませんが、執筆体験を確保するにはできるかぎり型を付けることが重要だと考えています。
理由は以下の通りです。

- 記述に制約を与えることで文書ファイルの構造を考慮する必要を無くし、執筆に集中できる
- 引数の個数を誤った場合に実行時エラーを起こすしかない
- 特定のコマンドが引数の性質を制限する方法がない
- 誤ったコマンドの呼び出し方をLanguage Serverを通じて高速にユーザにフィードバックする必要がある

テキストへの変換であればそれほど時間はかかりませんから、実行時エラーを中心に設計しても十分に高速だと考えられます。
しかし、フックを用いたスライドやPDF、その他時間を要する変換を行う場合にはユーザの執筆体験を大きく損なう危険性があります。
SATySFiのようにできるだけ厳密にコマンドを静的に検査しつつ、プラグインを実装する際には平易に型情報を与える仕組みが必要です。

メタデータの節で説明したように、Wasmバイナリを解析して型情報を決定することは難しいでしょう。
プラグインをWasmバイナリで扱うメリットとして複数の言語からプラグインを書けるということが挙げられますので、特定の言語に依存した型情報を使うことも望ましくありません。
そこで、メタデータに独自の型情報を記述することを考えています。

```
{std.list
  [std.list-elem hoge1],
  [std.list-elem hoge2],
  [std.list-elem hoge3],
}
```

リストは`std.list-elem`のみを取るという制約を与えたいとします。
`std.list-elem`コマンドの呼び出しからは`StdListElem`型（ここではコマンド呼び出しからは`ModuleCmd`型が帰るという仮定を置きます）が帰ると推論できるので、`std.list`は`varargs StdListElem -> StdList`という型シグネチャを取るはずです。
後者をメタデータで与えることで執筆時にLanguage Serverを介して制約を与えられそうです。

また、「という考え」で終わるような箇条書きのみを認めるリスト要素`list-thought-elem`を作りたいとします。
`Tail text-lit`が`text-lit`で終わる文字列を許容する型だとすれば、この要素は`Tail という考え -> StdListThoughtElem`というシグネチャを取れば良いです。
そうすると`std.list`は今のシグネチャのままでは`std.list-thought-elem`を要素に取れませんから、`varargs (StdListElem | StdListThoughtElem) -> StdList`のような直和型、あるいは最終的に対象のバックエンド`backend`の要素`elem`に変換されるコマンドのインタフェースである`Converted backend elem`型を用意して、`varargs (Converted html li) -> StdList`のような型付けをしなければいけないのかもしれません。
Brackには文字列以外の、整数型や真理値型などのデータ型は現在は存在していないので、文字列やコマンド呼び出し構造を上手く型システムに落とし込んで検査する必要がありそうです。
簡単な型検査器を作ったことはありますが、実用に耐え得る型検査器を作ったことはないので、TaPLなどを読みながら学んでいきたいと考えています。

= 計画
この節では1年間の計画について述べます。こちらでは私の担当の計画のみを記述します。

== 現在の進捗
まずは現在の進捗について説明します。
Brackのソースコードは https://github.com/brack-lang/brack で公開されています。

Nimで実装していた頃のBrackは https://github.com/brack-lang/brack/tree/v0.0.1 にあり、実際にこれを用いて https://github.com/momeemt/blog.momee.mt を動かしています。
こちらは2022年の8月〜2023年の1月の間に実装しており、Nimによるプラグインの追加、HTMLへの変換などが出来ます。

字句解析や構文解析、メタデータを含む簡単なプラグインシステム、非常に簡易的なプラグインマネージャ、部分的なLanguage Serverを実装しています。
こちらは2023年12月から実装を開始し、期末試験などの事情もありペースは芳しくありませんがゆっくりと実装を進めています。
HTMLファイルへの変換、プラグインのインストールなどが出来ます。
HTMLに変換するための標準ライブラリは https://github.com/brack-lang/std.html で公開しています。

== 優先順位
応募書類ではやりたいことを羅列したのでここでは優先順位について説明します。

1. 言語設計
2. プラグインの安定化
3. フックの実装
4. 型システムの実装

まず、ラボユースの機会を通してBrackの基本的な言語設計については確定させるべきです。
議論を通じてBrackが解決するべき課題を明らかにしつつ、必要な機能や制約を定めることで長期的にBrackの開発がスムーズになります。
次にプラグインの安定化を行い、HTML、JSONをバックエンド言語の対象にした標準ライブラリを整備します。
実際にBrackのユーザを増やすためには簡単に使ってもらえる環境を整えることが重要です。もちろん環境構築の容易さなども考慮されるべきですが、まずはHTMLやJSONなどの需要が高いと思われる言語への標準ライブラリを実装する必要があります。
3番目にフックについて検討して実装を行います。スライドや画像、その他テキストに完結しないバイナリを含むファイルに変換する場合にはこれが必要です。
型システムの実装は最後に回します。強力な型システムがBrackに追加できればそれは1つの大きな武器になりますが、上野と議論する中で、Language Serverからの補完や支援を充実させれば執筆体験を維持するのに必須とは言えないのではないかという意見も出ています。
また、型システムは十分に学習することなく短期的に決定すれば破綻したり、不完全な型システムを抱える可能性が高まります。
何度か時間がある時に効果を確かめる目的で実装してみたいですが、早く実用に達することを考えれば後回しでも良いと思っています。

== スケジュール
次に実装や議論のスケジュールについて説明します。

=== 2024年4月

- ラボユースへの応募
- wasmparserの導入
- READMEの作成

応募書類の執筆と応募を行います。

また、現在はExtismというライブラリを用いてプラグインシステムを実装していますが、wasmparserを用いてWasmバイナリを解析して関数名などを取得します。
これはExtismの開発元であるdylibso社が、Wasm関連の商用ライブラリを販売しており、（おそらく技術的にではなく商用的な都合で）Extismから動的に定義済みの関数などを取得できないという制約があるからです。
メタデータや型システムなどを実装するためにはそれが必要なので、低レベルなパーサであるwasmparserを導入して解析側ではこちらを使うようにします。

=== 2024年5月

- 言語設計の議論（括弧の意味論）と仕様の執筆
- std.html（HTMLに変換する標準ライブラリ）の実装
- Homebrewへの公開とリリース作業の自動化

開始後は括弧の意味論について議論したいと考えています。
また、Brackは既存のマークアップ言語の抽象化と考えられるので、既存のマークアップ言語に関する情報や先行研究を収集して分析します。
Markdownの弱点としてオリジナルの仕様が存在しなかった点が挙げられるので、確定したことから順に仕様を記述します。

実装の面では、HTMLに変換するための標準ライブラリを実装します。
また、Homebrewへの公開とリリース作業の自動化に取り組みます。

=== 2024年6月

- 仕様の執筆（プラグインを除く言語仕様）
- std.htmlの実装
- プラグインマネージャの実装

プラグインを除く言語仕様を引き続き書きます。
また、std.htmlの実装に引き続き取り組みます。

Releaseに公開されたバイナリをフェッチしてディレクトリに格納し、
設定ファイルを読んでビルドするだけの非常に簡単なプラグインマネージャ・ビルドツールがありますが、
これを実用的なソフトウェアにします。
具体的には対話的なプロジェクト作成・ビルドや、設定項目の決定などがあります。

=== 2024年7月

- プラグインに関する仕様の執筆
- フックの設計
- プラグインマネージャの実装

プラグインに関する仕様を書きます。
現在は完全にExtismというライブラリに依存していますが、理想的には望ましい状態ではありません。
データの変換方法、値の渡し方などについてより一般的な内容を仕様として決めることができれば、
Extismが対応していないがWasmには変換できる言語でもBrackのプラグインを開発できるので健全そうに思えます。
この辺りは議論の上、決定していきたいと考えています。

また、フックの設計を行います。

=== 2024年8月

- フックの実装
- VSCodeのプレビュー拡張機能を実装する

ビルド結果をリアルタイムに表示しながら執筆ができるVSCodeの拡張機能を実装します。
また、設計したフックを実装します。

=== 2024年9月

- ベータ版をリリースする
- Nixやapt-getなどさまざまなパッケージマネージャでインストールできるようにする
- 自分で試したり知り合いに試してもらう

ベータ版をリリースします。
ベータ版とは、少なくともHTMLに問題なく変換でき、環境構築方法が平易で、対応する言語でプラグインを書け、上野のLanguage Serverの核の機能が利用できる状態です。
フックについては実験的機能としたままリリースします。
どちらかの進捗状況によっては前後する可能性があります。

私の仕事としてはさまざまなパッケージマネージャでインストール可能にし、環境構築方法をできるだけ平易にします。
また、夏休みである程度時間があると考えられるので、https://github.com/momeemt/blog.momee.mt を改修してドッグフーディングしてみたいとも思っています。

=== 2024年10月

- バグの修正
- 仕様の執筆
- フックの修正
- ドキュメントの作成

ベータ版をリリースして利用者を増やすことに努めます。日英どちらのIssue Templateも作成して、ハードルを下げます。
コミュニティサーバを用意して誰でも質問できるようにします。
その間に上がってきたバグの修正や仕様の執筆に取り組みます。

=== 2024年11月

- 型システムの検討
- Language Server側のヘルプ
- フォーマッタやリンタの検討
- ドキュメントの作成

ここまででプラグインの基本的な仕組みと言語設計、フックの実装はある程度目処がつくのではないかと考えています。
基本的にはLanguage Server側の、特にプラグインが絡む内容についてのヘルプをします。
また、フォーマッタやリンタの導入を検討して、2025年以降に必要であれば開発していきたいと考えています。

型システムの導入は現時点では有用だと考えているので、学習をしつつ導入を検討します。

=== 2024年12月・2025年1月

- ドッグフーディング
- 型システムの設計
- デモの作成

この2ヶ月間は型システムの設計とドッグフーディングに取り組みます。
GPTを使って文書を書き換える機能など現在考えているプラグインの開発例を作ったり、HTML以外のバックエンド言語をサポートしたり、スライドなどのフックを使ったソフトウェアを開発する期間にします。

=== 2025年2月・3月・4月
現実的には大学の定期試験やインターンシップなどが入ることが想定されるので、スケジュール通りに遂行できない可能性もあります。
そこでバッファ期間を3ヶ月設けます。もし仮に全てがスムーズに進んでいた場合には、型システムの実装を進める予定です。
また、3月ごろに例年はラボユースの発表期間がありますので、発表資料作成などに取り組みたいと思っています。
学内の情報特別演習II（例: https://www.cs.tsukuba.ac.jp/~kam/special-seminar/）という授業でもこのプロジェクトを進めようと考えておりますので、
先行文献などを十分に調べたわけではないので不確定ではありますが論文化して情報処理学会等で発表できれば有意義だなとも思います。

= 自己アピール
#include "momeemt-exp.typ"
