#set text(font: "Hiragino Kaku Gothic ProN")

= 開発したいテーマ
私は拡張性を高く持つマークアップ言語であるBrackを開発したいと考えています。
このテーマは同日に提出された上野幹太さんと共同で進めているプロジェクトで、担当箇所を明確に切り分けています。
私はプラグインの実装とプロジェクト管理を中心に、彼はパーサとLanguage Serverの実装を担当します。
お互いの書類でBrackの概要と担当箇所のやりたいことについて説明します。

== Brackの概要
#include "brack-overview.typ"

== 言語設計
ラボユースに応募する最も大きな動機は言語設計について議論したいという点です。
Brackは2022年の夏に自分のブログを書くためのマークアップ言語として開発を始めました。
当時は何かの問題を解決することよりも「自作のマークアップ言語でブログを書きたい」というモチベーションの方が強く、単純な文法とWasmによるプラグインシステムによってマークアップ言語を作れることでドメイン固有な文書の執筆体験を改善できるかもしれないと気が付いたのはごく最近のことです。
これからBrackを実用的な言語にするためには、大量の文法要素、言語機能について、明確な理由の元に言語設計をする必要があると思います。
一方で私と上野は大学入学以降に言語処理系を学び始めたために全て自分たちで正しい決定を行えるとは思っていません。
外部の知見を持ったエンジニアの方と定期的に言語設計について議論することはBrackにとって非常に有用であるはずです。
以下に、具体的に迷っている言語機能を述べます。

=== コマンドの分類
当初はHTMLに変換する言語としてBrackを考えていたため、HTMLのインライン要素（`[]`）とブロック要素（`{}`）、マクロ（`<>`）に対して3種類の括弧列を割り当てました。
しかし、Brackは複数のバックエンド言語を想定していますから、HTMLのインライン要素とブロック要素という区別は適当ではないように感じています。
たとえば、スライドを出力するためにBrackを用いるならば`[]`と`{}`の意味論的な区別はあるのでしょうか。
一例として、通常のコマンド呼び出しを`[]`に統一して、エディタ上で実行されるスニペットコマンドを`{}`に割り当てるという案があります。

```
{std.list
  [std.list-elem hoge1],
  [std.list-elem hoge2],
  [std.list-elem hoge3],
}
```

仮にHTMLバックエンドであれば`std.list`は`ul`要素に、`std.list-elem`は`li`要素に変換されるでしょう。
しかしこれは冗長です。Markdownであれば以下のように記述できます。

```md
* hoge1
* hoge2
* hoge3
```

TeX/LaTeXの代替として関数型組版言語のSATySFiがありますが、LaTeXに対して執筆体験が非常に改善されているにも関わらずユーザ数はそれほど多くありません。
インストール手順にOCamlのパッケージマネージャであるduneが利用されている、ライブラリを書くのにduneの知識が必要である、具体的にはOCamlベースの文法によるコマンド定義などのSATySFi固有の難しさが、LaTeXを代替するところまでは行っていない1つの要因だと思います。
一方で近年急激にTypstが新たな組版言語として台頭しており、大学教員の間でも実用される機会が増えているようです。
TypstはRe:ViewやMarkdownを感じさせる軽量な文法を持ちながらも非常に導入が簡単な組版言語で、Language ServerやHot reloading serverを提供しており執筆体験も保証されています。
SATySFiはTypstよりも抽象化されており、特に自分でコマンドを定義したりライブラリを作るのであれば静的型付けにより安心して開発ができる素晴らしい言語だと感じますが、文書を書いてPDFを作りたいユーザはそこにコストを掛けるのを嫌がったのだと思います。
実際にこの申請書類もインストールの問題を避けるためにSATySFiではなくTypstで管理しています。

このように、言語の利用者は「環境構築」「執筆体験」「簡単に目的が達成できるか」などを重要視しており、言語的に厳密であるか、高速であるか、致命的なエラーが発生しないかなどは考慮されていないように思います。
Brackにおいては単純なコマンド呼び出しのみで構成されていることが重要なコンセプトの1つですが、リストやテーブルのように複雑な構造を取る場合には冗長になることがあります。
そこで、`{}`をエディタ上で特定の記法をBrackのコマンド呼び出し記法に変換するためのスニペットとして利用します。
具体的には、次のようなスニペットを、

```
{std.list
  - hoge1
  - hoge2
  - hoge3
}
```

次のようなコマンド呼び出しに変換するということです。

```
[std.unorder-list
  [std.- hoge1],
  [std.- hoge2],
  [std.- hoge3],
]
```

プログラムには書く側面と読む側面があります。
強力な表現力を持ち、抽象化されたプログラムは書きやすいですが読み下すのに時間がかかります。
他方、Go言語のようにフォーマッタや限定された文法によって誰が書いても同じようなプログラムに仕上がる設計にすることで読みやすさを担保する方針もあります。
Brackの「文法を単一のコマンド呼び出し構文に限定する」という方針は、大きく3つの利点から採用しています。

- パースしやすい・文法の複雑性を排除できる（読みやすさ）
- 記法を覚える必要がない（書きやすさ）
- 拡張することを前提に置くため

もしスニペットを採用すれば、人間やパーサなどの読む側にとってはBrackのコマンド呼び出し構文で表現されており、書く側にとっては複雑な構文を平易な文法で代替できます。
ただし、スニペットを導入することに対して幾つかの不安もあります。

- プラグインの塩梅によってユーザが記法を理解するために新たな負担を受ける可能性があり、Brackの最小の文法と拡張による言語というコンセプトも壊れかねない
- スニペットで展開されたコードに対してエラーが発生すると執筆体験を損ねる
- 書いたコードが別のコードになって保存されることへの抵抗感

Brackを実用的な言語として作っていくために、基本的にBrackが持つ言語機能とそれが提供する嬉しさを固めたいと思っています。

== プラグイン
Brackの核は文法ではなくプラグインにあります。
プラグインはWebAssemblyのバイナリを指しており、Brack文書をパースすることにより得られるプラグイン名とコマンド名を元に、Wasmバイナリを呼び出します。
一見シンプルな仕組みですが、執筆体験と汎用性を維持するためには考慮するべきことが多くあります。

=== メタデータ
Wasmは静的に型付けがされますが、組み込み型としては整数型のみを持ちます。
実装に用いているExtismは何らかのルールによって構造体や文字列などをメモリ上に展開しているのですが、その影響でRustなどが本来持っている型の表現力による恩恵をそのまま受けることはできません。
具体的には、Extismはプラグイン関数に対して1つの引数のみを持つことを要請するため、複数のデータをやり取りしたい場合には構造体を用いることで、可変長引数を表現したい場合には`enum`を用いることで対処するしかありません。
しかし、こうなるとバイナリから関数がどのようなデータを要求しているのかを読み出すのは非常に困難です。
そこで、Brackの実装ではあらかじめプラグインを読み出した時点で以下の情報を得るための関数を連続して呼び出します。この情報を便宜的にメタデータと呼んでいます。

- (Brackにおける) コマンド名
- (Wasmバイナリにおける) 関数名
- 引数型
- 戻り値型

メタデータを初期化時に得ることで、Wasmを詳細にパースする必要がなくプラグインシステムを実現できます。

=== セキュリティ
Wasmによるプラグインを扱うにはセキュリティリスクに十分注意する必要があります。
BrackのプラグインはWebAssembly System Interface（以下、WASI）を有効にしていますが、サンドボックスの制御を怠れば
文書に潜んだ悪意のあるプラグインによって執筆者の計算機環境に被害を出す可能性があります。
プラグインシステムを設計する際には、単にWasmを使うだけでなく本質的な構造を理解して対策しなければなりません

=== フック
現行のBrackのプラグインはバックエンド言語としてHTML以外も選択できますが、テキストファイル以外への変換も考えています。
具体的にはBrackでスライドを作りたい場合を考えます。
プラグインシステムが可能なのは基本的にテキストを別のテキストに置換する、あるいはASTを別のASTに置換することです。
したがってそのままでは画像やPDFのフォーマットを取ることが想定されるスライドの作成は難しいように思えます。

ここで、フックを導入したいと考えています。
フックはBrackのASTから変換されたJSON（などのデータ）を入力に何らかの操作を行うプログラムのことです。
Brackのファイルから構築されたデータを元に、任意のプログラムを実行します。

#align(center)[
  #image("./figure1.jpeg", width: 60%)
]



=== 型付け
Brackには現状型システムがありませんが、執筆体験を確保するにはできるかぎり型を付けることが重要だと考えています。
理由は以下の通りです。

- 引数の個数を誤った場合に実行時エラーを起こすしかない
- 特定のコマンドが引数の性質を制限する方法がない
- 誤ったコマンドの呼び出し方をLanguage Serverを通じて高速にユーザにフィードバックする必要がある

テキストへの変換であればそれほど時間はかかりませんから、実行時エラーを中心に設計しても十分に高速だと考えられます。
しかし、フックを用いたスライドやPDF、その他時間を要する変換を行う場合にはユーザの執筆体験を大きく損なう危険性があります。
SATySFiのようにできるだけ厳密にコマンドを静的に検査しつつ、プラグインを実装する際には平易に型情報を与える仕組みが必要です。

メタデータの節で説明したように、Wasmバイナリを解析して型情報を決定することは難しいでしょう。
プラグインをWasmバイナリで扱うメリットを最大化するために、

= 計画

= 自己アピール
プログラミングを始めたのは中学3年生の秋で、情報科学の専門教育を受け始めたのは大学生になってからです。
これまでのエンジニアリングにおける活動を述べます。

== Brackの設計と実装

== 情報科学類新入生歓迎委員会

== ピクシブ株式会社

== 学園祭実行委員会

== 学内の研究資金採択経験

== SWEST24における講師経験

== WCCE2022における発表経験

== インヴァスト株式会社

== 「プログラミングNim」の出版

== mock up

== Piledit

== Nim製の自作OSの開発

== 文化祭実行委員会

== 資格試験

== 奨学金
