#set text(font: "Hiragino Kaku Gothic ProN")

/*
意識しておきたいこと
・どうしてもうまくいかなくてギブアップしたら私に質問してもらって、私は最低限のヒントを与えてあとは自力で突破してもらう
・何か目的があって、その手段として言語やライブラリを作るという説明になっているといい
・自分自身のプログラミングを今よりもやりやすくすることが目的
・今後の開発の助けになるような開発もして、自分の開発効率を改善していきたい
・自分がどんなプログラミング言語を作りたいと思っているのか、もしくはどんなライブラリを作りたいと思っているのかを自由に書いて
・現状の説明

---

目的の動機になりそうなエピ
・Wordとバトルした
・markdown組版(CSS)
・SATySFi(+LATEX)に敗北

目的
・高い拡張性を持ちながら、執筆体験を損なわないマークアップ言語
・高い拡張性(プラグインシステム)
・執筆体験を賢いLanguage Serverにより実現。

具体的な目標
理想
  ・プラグインがLanguage Serverの機能に介入することによる高精度な入力補完(Completion)
  ・Inaly Hint、Signature Helpを用いた執筆体験の向上
現時点の目標
  ・Semantic Tokensを用いたシンタックスハイライト
  ・Tokenize Error、Parse Errorのdiagnosticを表示
    ・欠けたdocumentを適切にParseし、入力補完を行う

---

自己アピールエピ
・「Go言語で作るインタプリタ」のRustによる実装
  ・Prattパーサの実装
  ・絵文字への対応
  ・代数的データ型によるパターンマッチとか
・講義「プログラム言語処理」を受講
  ・LR構文解析とか、わかります(笑)
・正規表現エンジンの実装
  ・DFA式(といいつつNFA)
  ・知識が浅かったため、オレオレ実装だが動いた！！
・SATソルバー作りました!
  ・DPLL
  ・なんか、型推論とかと関係あるんすよね？w
・元は制御とかアルゴリズムとかに興味もありました。
  ・中学生の頃からレゴのロボコンに参加し、ビジュアルプログラミングでPID制御やってました
    ・改良もしました。
    ・他のアルゴリズムもたくさん生やしました。
  ・機械学習のMomentumをPI制御とみなし、それをPIDに拡張する実験とかもやってみました。
  ・CMA-ESに興味とかもあって、PIDパラメタのCMA-ESによる最適化とかもやりました。
  ・シフト自動生成、試しました。できませんでした。(笑)

*/

= 開発したいテーマ
私は拡張性と執筆体験を両立するマークアップ言語であるBrackおよびそのLanguage Serverを開発したいと考えています。
このテーマは同日に提出された浅田睦葉と共同で進めているプロジェクトで、担当箇所を明確に切り分けています。
私はパーサとLanguage Serverの実装を中心に、彼はプラグインの実装とプロジェクト管理を担当します。
お互いの書類でBrackの概要と担当箇所のやりたいことについて説明します。

== Brackの概要
#include "brack-overview.typ"

== 動機
私は以前、Wordを用いて体裁が厳格に定められた文書の作成を行なっていたことがあります。
しかし、そこでさまざまな機能的問題に直面しました。
例えば、Wordでは数多くの設定を細かく調整することで、文章の体裁を整えることができますが、その分どの設定が何を意味しているのかを正確に把握することが大変難しいです。時には、設定同士が競合し、思わぬ体裁の変更が起こることもあります。
また、細かく調整した設定について、Wordが勝手に変更を加えることもあります。そのため、少し執筆しては確認、という作業を繰り返すことが多くなり、執筆体験が損なわれることがありました。他にも、バグとしか思えない様な挙動や、再現性のない体裁崩れ、PDF出力時の体裁の変化など、Wordの問題は尽きません。
ドキュメントが整備されておらず、インターネットに知見が溜まっていないことも執筆体験の悪化に拍車をかけました。

また、Markdownを用いた執筆を試みたこともあります。
Markdownはシンプルであるため、執筆体験は非常に良いものでした。しかし、体裁を指定したい場合など、少しでも拡張を行う場合、CSSを用いたスタイルの指定が必要になり、さらにこれらの拡張はVSCodeの拡張機能に依存しており、拡張性の低さが問題となりました。
他にも、SATySFiやLaTeX等の組版言語も検討しましたが、学習コストが高く、とっつきづらさを感じていました。

そこで、友人が開発していたシンプルかつ拡張性を持ったマークアップ言語に魅力を感じ、また、言語開発への興味や、他人との共同開発へのモチベーションから、Brackの開発に参加することにしました。
Brackの開発に参加する上で、私は執筆体験の向上を行いたいと考え、Language Serverの開発およびそのためのパーサの実装を担当することになりました。

== 目標
Language Serverによって執筆体験の向上を行うために最も必要な要素は、高度な入力補完(Completion)やInaly Hint等のアノテーションからの情報です。例えば、以下の様な記述を行いたい場合、`std.list`まで書いた時点で、`[std.list-elem ]`の入力が補完されると、執筆体験が向上すると考えられます。

```brack
{std.list
  [std.list-elem hoge1],
  [std.list-elem hoge2],
}
```
これを実現するには、`std.list`が`std.list-elem`コマンドのみを引数に持つ、という制約をプラグインが定め、Brackがそれに基づき検査する必要があります。
しかし、この制約は、プラグイン開発者が`std.list-elem2`の様なコマンドを作成したい場合等を考慮すると適切な制約ではないでしょう。
そこで、この補完に近い体験を提供するために、二つの選択肢を検討しています。

その一つが、プラグインによるLanguage Serverへの介入です。あるコマンドが入力された場合や、引数が入力された場合等のいくつかのトリガーに対して、挿入・置換・削除等のBrackが用意したAPIをプラグインが呼び出すことで、入力補完を実現することができます。
また、警告を表示する様なアクションを用意することで、コマンドの引数に応じてプラグインが警告を表示することも可能です。
ただしこれらは、プラグイン開発の負担を大きくし、また、執筆体験がプラグインに応じて大きく異なってしまう可能性があります。

二つ目が、型システムによる入力補完です。
これは、コマンドを入力した時に自動で引数を補完してくれる様な強力な入力補完は実現できませんが、プラグイン開発の負担や、プラグインごとの執筆体験のばらつきといった問題を解決することができます。
ただし、これを実装するためには先に型システムの設計・実装が必要となり、開発コストがかかります。

上記の様な補完が難しい場合でも、Inaly Hintの活用によって、補完によって行いたかった執筆体験工場の一部を行うことができます。
Inaly Hintとは、コード上の任意の場所にアノテーションを表示できる機能であり、一般的なプログラミングにおいては、引数の型や戻り値の型のアノテーションを表示する機能として利用されます。
Brackにおいては、プラグインのメタデータの一部として、コマンドの引数についてのアノテーションを指定することで、プラグイン開発者が容易にこのアノテーションを設定することが可能です。先ほどの例で言えば、`std.list`の引数に対して`list-elem`の様なアノテーションをつけることで、執筆者はどの様なコマンドを入力すべきかを把握しやすくなります。

私はラボユースでの開発を通して、これらの未確定な機能の設計・実装を行い、Brackの執筆体験の向上に貢献したいと考えています。

== 現状

現時点では、私はLanguage Serverの基本的な機能であるDiagnosticsの実装を行なっています。
Diagnosticsは、Brackの文法に違反した箇所を検出し、エラーを表示する機能です。VSCode等では、赤や黄色の波線で出される警告がこれに該当します。
