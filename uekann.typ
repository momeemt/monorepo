#set text(font: "Hiragino Kaku Gothic ProN")
#set page(numbering: "1 / 1")


/*
意識しておきたいこと
・どうしてもうまくいかなくてギブアップしたら私に質問してもらって、私は最低限のヒントを与えてあとは自力で突破してもらう
・何か目的があって、その手段として言語やライブラリを作るという説明になっているといい
・自分自身のプログラミングを今よりもやりやすくすることが目的
・今後の開発の助けになるような開発もして、自分の開発効率を改善していきたい
・自分がどんなプログラミング言語を作りたいと思っているのか、もしくはどんなライブラリを作りたいと思っているのかを自由に書いて
・現状の説明

---

目的の動機になりそうなエピ
・Wordとバトルした
・markdown組版(CSS)
・SATySFi(+LATEX)に敗北

目的
・高い拡張性を持ちながら、執筆体験を損なわないマークアップ言語
・高い拡張性(プラグインシステム)
・執筆体験を賢いLanguage Serverにより実現。

具体的な目標
理想
  ・プラグインがLanguage Serverの機能に介入することによる高精度な入力補完(Completion)
  ・Inaly Hint、Signature Helpを用いた執筆体験の向上
現時点の目標
  ・Semantic Tokensを用いたシンタックスハイライト
  ・Tokenize Error、Parse Errorのdiagnosticを表示
    ・欠けたdocumentを適切にParseし、入力補完を行う

---

自己アピールエピ
・「Go言語で作るインタプリタ」のRustによる実装
  ・Prattパーサの実装
  ・絵文字への対応
  ・代数的データ型によるパターンマッチとか
・講義「プログラム言語処理」を受講
  ・LR構文解析とか、わかります(笑)
・正規表現エンジンの実装
  ・DFA式(といいつつNFA)
  ・知識が浅かったため、オレオレ実装だが動いた！！
・SATソルバー作りました!
  ・DPLL
  ・なんか、型推論とかと関係あるんすよね？w
・元は制御とかアルゴリズムとかに興味もありました。
  ・中学生の頃からレゴのロボコンに参加し、ビジュアルプログラミングでPID制御やってました
    ・改良もしました。
    ・他のアルゴリズムもたくさん生やしました。
  ・機械学習のMomentumをPI制御とみなし、それをPIDに拡張する実験とかもやってみました。
  ・CMA-ESに興味とかもあって、PIDパラメタのCMA-ESによる最適化とかもやりました。
  ・シフト自動生成、試しました。できませんでした。(笑)

*/

= 開発したいテーマ
私は拡張性と執筆体験を両立するマークアップ言語であるBrackおよびそのLanguage Serverを開発したいと考えています。
このテーマは同日に提出された浅田睦葉と共同で進めているプロジェクトで、担当箇所を明確に切り分けています。
私はパーサとLanguage Serverの実装を中心に、彼はプラグインの実装とプロジェクト管理を担当します。
お互いの書類でBrackの概要と担当箇所のやりたいことについて説明します。

== Brackの概要
#include "brack-overview.typ"

== 動機
私は以前、Wordを用いて体裁が厳格に定められた文書の作成を行なっていたことがあります。
しかし、そこで以下の様な機能的問題に直面しました。
- 重複・競合する設定
- 意図しない自動での体裁変更
- 再現性のないバグの様な挙動
- インターネット上の情報が少ない
Wordでは数多くの設定を細かく調整することで、文章の体裁を整えることができますが、その分どの設定が何を意味しているのかを正確に把握することが大変難しいです。例えば、箇条書きの設定はインデントの設定も変更してしまう上、箇条書きの設定時に自身がすでに設定しているインデントとは違う設定を標準で登録するため、注意を払わないと競合してしまうことがあります。
他にも、様々な欠陥がありますが、残念ながらそのような問題を解決するための情報はインターネットにほとんどありませんでした。

これは、WordがWYSIWYGエディタであり、文書の見た目のみを表示するようなインターフェースであることが根本の原因であると感じました。
そこで、WordのようなGUIエディタではなく、構造と体裁が分離したマークアップ言語であって、かつ言語としての情報が豊富なものを求め、Markdownを使用することにしました。

Markdownはシンプルであるため、執筆体験は非常に良いものでした。
しかし、Markdown自身には目次やページ番号や注釈といった機能はなく、また、見出しなどの体裁を指定してPDFに出力することもできません。
その様な文書を作りたい場合は、リンクを用いた箇条書きで目次を表現したり、HTMLに変換しCSSで体裁を整えてPDFに出力するといった方法をVSCodeの拡張機能を用いて行う必要がありました。
Markdownは簡単な記事を執筆したり議事録を取ったりする際には非常に便利ですが、体裁が厳格に定められた文書を作成する際には拡張性の低さが問題でした。
また、SATySFiやLaTeX等の組版言語は、拡張性が高く、情報がある程度提供されているマークアップ言語として良い選択肢に思ましたが、学習コストの高さや周辺ツールの不足てを出しづらく感じました。

そこで、友人が開発していたマークアップ言語Brackに興味を持ちました。
Brackは構文がシンプルな軽量マークアップ言語であり、また、プラグインとしてWasmを用いることができるために拡張性が高く、理想的な言語でした。
しかし、いくら良い言語でも言語の仕様や使い方についての情報がなければ執筆体験は悪化してしまいます。
この問題を、Brackの賢いLanguage Serverを作ることで解消しようと考え、また言語開発への興味や、他人との共同開発へのモチベーションから、Brackの開発に参加することにしました。
Brackの開発に参加する上で、執筆体験の向上に欠かせないLanguage Server及び、その実装のために必要なパーサ等の実装を担当することにしました。

== 実装するもの

私はラボユースでの開発を通して、以下の様々な機能を実装したいと考えています。
また、いくつかの機能について、未確定な仕様もあります。
そのような仕様についてラボユースでのインターンを通じ議論を行っていきたいです。
具体的に実装したい機能・検討している仕様には以下のようなものがあります。

=== Diagnostics

Diagnosticsとは、エラーが起きた箇所をエディタ上で示す機能のことで、VSCode等のエディタでは赤い波線で表示される警告のことです。
これはLanguage Serverとして最も基本的な必須の機能であるため、はじめに実装を進めています。
Diagnosticsを表示するためには、Tokenize、Parse、実行時にエラーが起きた際、それの原因となる箇所を特定する必要がありますが、現在Brackのパーサはパースに失敗する直前に読み込んだTokenをエラー箇所っとして返すプログラムになっており、また、エラーメッセージもドキュメントの原因を指摘するものではありません。
そこで、まずはじめにBrackのパーサのエラーハンドリングを適切に行い、エラーの原因の分析を行うことを目標として実装を行います。

また、Diagnosticsは本来実行時にエラーが起きた際、その箇所を指摘する必要がありますが、フックのような仕組みを導入した場合、エラー箇所を指摘するのが大変困難になります。
この問題の対応については現在検討中です。

== Hover

Hoverは、ドキュメント上のトークンに対して情報を表示することができる機能です。
プラグインに定義されたコマンドの使用方法などについての情報を提供するためには必須であり、Diagnostics同様優先度の高い機能であると言えます。
また、表示する内容はMarkdownで記述された各コマンドについての説明であるため、プラグインのメタ情報を提供する関数で説明文を受渡することで素直に実装することが可能です。

== Completion

Language Serverによって提供できる情報のうち、最も執筆体験の向上に寄与する機能の一つは入力補完です。
これは、単に単語等を途中まで入力した際に補完してくれる機能はもちろんのこと、今後入力すると予測できる内容を補完するような機能があればことでより良いでしょう。
例えば、以下の様な記述を行いたい場合、`std.list`まで書いた時点で、`[std.list-elem ]`の入力が補完されると、執筆体験が向上すると考えられます。

```brack
{std.list
  [std.list-elem hoge1],
  [std.list-elem hoge2],
}
```
これを実現するには、「`std.list`が`std.list-elem`コマンドのみを引数に持つ」という様な、コマンド内の引数を特定のひとつのコマンドのみに限定する制約をプラグインが定め、Brackがそれに基づき検査する必要があります。
しかし、この制約は、プラグイン開発者が`std.list`の引数に別のコマンド(例えば`std.list-elem2`)を許容できなくなってしまい、不都合が多いです。
別のコマンドを引数に取ることを許容する場合、入力補完するコマンドが一意に定まらなくなってしまいます。
そこで、この補完に近い体験を提供するために、二つの選択肢を検討しています。

その一つが、プラグインによるLanguage Serverへの介入です。あるコマンドが入力された場合や、引数が入力された場合等のいくつかのトリガーに対して、挿入・置換・削除等のBrackが用意したAPIをプラグインが呼び出すことで、入力補完を実現することができます。
また、警告を表示するアクションを用意することで、コマンドの引数が違うなどの問題が存在したときにエラー通知できます。
ただしこれらは、プラグイン開発の負担を大きくし、また、執筆体験がプラグインに応じて大きく異なってしまう可能性があります。

二つ目が、型システムによる入力補完です。
これは、コマンドを入力した時に自動で引数を補完してくれる様な強力な入力補完は実現できませんが、プラグイン開発の負担や、プラグインごとの執筆体験のばらつきといった問題を解決することができます。
ただし、これを実装するためには先に型システムの設計・実装が必要となり、開発コストがかかります。

ラボユースでのインターンを通じ、シンプルに単語を補完する入力補完の実装に加え、これらの言語仕様について検討・議論していきたいです。

== Inaly Hints

上記の様な補完が難しい場合でも、Inaly Hintの活用によって、補完によって行いたかった執筆体験の向上の一部を行うことができます。
Inaly Hintとは、コード上の任意の場所にアノテーションを表示できる機能であり、一般的なプログラミングにおいては、引数の型や戻り値の型のアノテーションを表示する機能として利用されます。
Brackにおいては、プラグインがコマンド引数のアノテーションをメタデータの一部としてBrackに提供することで、BrackのLanguage ServerがInaly Hintでアノテーションの表示を行うことができます。
先ほどの例で言えば、`std.list`の引数に対して`list-elem`の様なアノテーションを表示すれば、執筆者は入力するべきコマンドを把握しやすくなります。


=== Sementic Tokens

Sementic Tokensとは意味論に基づいたドキュメントのハイライトであり、文法に基づいて色付けされるSyntax Highlightとは違い、同じIdentifierでも関数か変数かによって色を分けることができる機能です。
Brackはその構造上、意味は文法によって一意に決定されるため現在はSyntax Highlightと同様の機能しか提供できませんが、プラグイン側がLanguage Serverの機能に介入できるようにした場合、例えば文書内のコードブロックに、そのコードの言語に従ったハイライトが付けられるかもしれません。

=== Folding Range

Folding Rangeはコードの折りたたみを行う機能です。
些細な機能ですが、長い文章を作成する際には有用な機能です。
また、Blackは必ずブロックを`{}`や`[]`で囲うという文法上の性質から簡単に実装できます。

== 計画

今後の実装は、最も優先度の高いDiagnosticsから行う予定です。
これは、Parserの改修が必要なため、時間を要すると考えられます。
7月中の実装を目指しています。
次に優先度の高いものはHover、Completion、Inaly Hintsですが、これらはプラグインシステムの仕様が決定し・ある程度実装されるまで開発を進めることができません。
そこでプラグインシステムの実装までにSementic TokensやFolding Rangeの実装を進めたいと考えています。
Diagnostics同様、7月中の実装を目指します。

プラグインシステムが完成次第、HoverやInaly Hintsの実装を進める予定です。
これはASTを元に表示される内容を決定し、トークン列を元に表示位置を決定する必要があるのでParserやASTそのものの改修の必要性が見込まれるため、Diagnostics同様時間を要すると考えられます。
これら機能はFolding Rangeなどより優先度が高いため、Folding Rangeなどの実装が終了していなくてもプラグインシステムの実装の目処が立ち次第実装を始めます。
12月ごろまでの実装を目指します。

最後にCompletionの実装を行う予定です。
これは今後決定されるBrackの言語仕様に大きく依存しますが、同時に執筆体験の向上にも大きく寄与する機能であるため、慎重に検討したのちに時間をかけて実装を進めたいと考えています。

= 自己アピール

私はこれまで、さまざまな技術に興味を持ち、それらの実装を通じて学習を進めてきました。

大学の講義でを通じて、基本的な言語処理系の仕組みについて学習し興味を持ちました。
そこで#link("https://www.oreilly.co.jp/books/9784873118222/")[Go言語で作るインタプリタ]に沿ったインタプリタの実装をRustで行い、講義では学べなかったPrattパーサの実装や、Goでは扱いにくい絵文字への対応、代数的データ型とパターンマッチによる構文解析など、独自の拡張を行いました。
また、関連する技術として正規表現にも興味を持ち、JavaでDFA式の正規表現エンジンを実装しました。
こちらは、参考にした実装等がなく、オートマトンについての知識のみで行なった独自実装であったため、DFAには変換できず、NFAでの動作となりましたが、イプシロン遷移の除去は行うことができ、連結・和・繰り返しといった基本的な正規表現のマッチは扱うことができます。
pythonを用いたSATソルバーの実装も行いました。こちらはDPLLアルゴリズムを用いた簡素なものですが、演算子オーバーロードにより`+,*,~`といった演算子を用いた式の記述や、探索がの終了条件に早く到達するための工夫を行いました。

言語処理に直接的には関連しない分野についても関心があります。
小・中学生の頃にレゴロボットのコンテストに参加し、PID制御などの大学で学ぶような制御を行なっていました。
その他にもロボットを素早く正確に制御するための試行錯誤を行い、三大会連続で世界大会に進出し、アジアで開かれた世界大会では優勝することができました。
また、機械学習に興味を持った際、勾配降下法のMomentumをPI制御として捉えることができると考え、それをPID制御に置き換える実験や、二次遅れ系に対するPID制御のハイパーパラメータの最適化を、共分散行列適応進化戦略というアルゴリズムを用いて行う実験などを行うなど、制御系の知識を活かした実験を行いました。

最近では大規模なシフトを線形最適化によって自動生成する試みを行い、自身の所属する委員会で導入したり、競技プログラミングをはじめ、atcoderでのレーティングは緑に到達しました。