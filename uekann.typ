#set text(font: "Hiragino Kaku Gothic ProN")
#set page(numbering: "1 / 1")


/*
意識しておきたいこと
・どうしてもうまくいかなくてギブアップしたら私に質問してもらって、私は最低限のヒントを与えてあとは自力で突破してもらう
・何か目的があって、その手段として言語やライブラリを作るという説明になっているといい
・自分自身のプログラミングを今よりもやりやすくすることが目的
・今後の開発の助けになるような開発もして、自分の開発効率を改善していきたい
・自分がどんなプログラミング言語を作りたいと思っているのか、もしくはどんなライブラリを作りたいと思っているのかを自由に書いて
・現状の説明

---

目的の動機になりそうなエピ
・Wordとバトルした
・markdown組版(CSS)
・SATySFi(+LATEX)に敗北

目的
・高い拡張性を持ちながら、執筆体験を損なわないマークアップ言語
・高い拡張性(プラグインシステム)
・執筆体験を賢いLanguage Serverにより実現。

具体的な目標
理想
  ・プラグインがLanguage Serverの機能に介入することによる高精度な入力補完(Completion)
  ・Inaly Hint、Signature Helpを用いた執筆体験の向上
現時点の目標
  ・Semantic Tokensを用いたシンタックスハイライト
  ・Tokenize Error、Parse Errorのdiagnosticを表示
    ・欠けたdocumentを適切にParseし、入力補完を行う

---

自己アピールエピ
・「Go言語で作るインタプリタ」のRustによる実装
  ・Prattパーサの実装
  ・絵文字への対応
  ・代数的データ型によるパターンマッチとか
・講義「プログラム言語処理」を受講
  ・LR構文解析とか、わかります(笑)
・正規表現エンジンの実装
  ・DFA式(といいつつNFA)
  ・知識が浅かったため、オレオレ実装だが動いた！！
・SATソルバー作りました!
  ・DPLL
  ・なんか、型推論とかと関係あるんすよね？w
・元は制御とかアルゴリズムとかに興味もありました。
  ・中学生の頃からレゴのロボコンに参加し、ビジュアルプログラミングでPID制御やってました
    ・改良もしました。
    ・他のアルゴリズムもたくさん生やしました。
  ・機械学習のMomentumをPI制御とみなし、それをPIDに拡張する実験とかもやってみました。
  ・CMA-ESに興味とかもあって、PIDパラメタのCMA-ESによる最適化とかもやりました。
  ・シフト自動生成、試しました。できませんでした。(笑)

*/

= 開発したいテーマ
私は拡張性と執筆体験を両立するマークアップ言語であるBrackおよびそのLanguage Serverを開発したいと考えています。
このテーマは同日に提出された浅田睦葉と共同で進めているプロジェクトで、担当箇所を明確に切り分けています。
私はパーサとLanguage Serverの実装を中心に、彼はプラグインの実装とプロジェクト管理を担当します。
お互いの書類でBrackの概要と担当箇所のやりたいことについて説明します。

== Brackの概要
#include "brack-overview.typ"

== 動機
私は以前、Wordを用いて体裁が厳格に定められた文書の作成を行なっていたことがあります。
しかし、そこで以下の様な機能的問題に直面しました。
- 重複・競合する設定
- 意図しない自動での体裁変更
- 再現性のないバグの様な挙動
- インターネット上の情報が少ない
Wordでは数多くの設定を細かく調整することで、文章の体裁を整えることができますが、その分どの設定が何を意味しているのかを正確に把握することが大変難しいです。例えば、箇条書きの設定はインデントの設定も変更してしまう上、箇条書きの設定時に自身がすでに設定しているインデントとは違う設定を標準で登録するため、注意を払わないと競合してしまうことがあります。
他にも、様々な欠陥がありますが、残念ながらそのような問題を解決するための情報はインターネットにほとんどありませんでした。

これは、WordがWYSIWYGエディタであり、文書の見た目のみを表示するようなインターフェースであることが根本の原因であると感じました。
そこで、WordのようなGUIエディタではなく、構造と体裁が分離したマークアップ言語であって、かつ言語としての情報が豊富なものを求め、Markdownを使用することにしました。

Markdownはシンプルであるため、執筆体験は非常に良いものでした。
しかし、Markdown自身には目次やページ番号や注釈といった機能はなく、また、見出しなどの体裁を指定してPDFに出力することもできません。
その様な文書を作りたい場合は、リンクを用いた箇条書きで目次を表現したり、HTMLに変換しCSSで体裁を整えてPDFに出力するといった方法をVSCodeの拡張機能を用いて行う必要がありました。
Markdownは簡単な記事を執筆したり議事録を取ったりする際には非常に便利ですが、体裁が厳格に定められた文書を作成する際には拡張性の低さが問題でした。
また、SATySFiやLaTeX等の組版言語は、拡張性が高く、情報がある程度提供されているマークアップ言語として良い選択肢に思ましたが、学習コストの高さや周辺ツールの不足てを出しづらく感じました。

そこで、友人が開発していたマークアップ言語Brackに興味を持ちました。
Brackは構文がシンプルな軽量マークアップ言語であり、また、プラグインとしてWasmを用いることができるために拡張性が高く、理想的な言語でした。
しかし、いくら良い言語でも言語の仕様や使い方についての情報がなければ執筆体験は悪化してしまいます。
この問題を、Brackの賢いLanguage Serverを作ることで解消しようと考え、また言語開発への興味や、他人との共同開発へのモチベーションから、Brackの開発に参加することにしました。
Brackの開発に参加する上で、執筆体験の向上に欠かせないLanguage Server及び、その実装のために必要なパーサ等の実装を担当することにしました。

== 実装するもの

私はラボユースでの開発を通して、以下の様々な機能を実装したいと考えています。

=== Diagnostics

Diagnosticsとは、エラーが起きた箇所をエディタ上で示す機能のことで、VSCode等のエディタでは赤い波線で表示される警告のことです。
これはLanguage Serverとして最も基本的な必須の機能であるため、はじめに実装を進めています。
Diagnosticsを表示するためには、Tokenize、Parse、実行時にエラーが起きた際、それの原因となる箇所を特定する必要がありますが、現在Brackのパーサはパースに失敗する直前に読み込んだTokenをエラー箇所っとして返すプログラムになっており、また、エラーメッセージもドキュメントの原因を指摘するものではありません。
そこで、まずはじめにBrackのパーサのエラーハンドリングを適切に行い、エラーの原因の分析を行うことを目標として実装を行います。

また、Diagnosticsは本来実行時にエラーが起きた際、その箇所を指摘する必要がありますが、フックのような仕組みを導入した場合、エラー箇所を指摘するのが大変困難になります。
このような問題は実装を進めながら、議論していきたいです。

=== Sementic Tokens

Sementic Tokensとは意味論に基づいたドキュメントのハイライトであり、文法に基づいて色付けされるSyntax Highlightとは違い、同じIdentifierでも関数か変数かによって色を分けることができる機能です。
Brackはその構造上、意味は文法によって一意に決定されるため現在はSyntax Highlightと同様の機能しか提供できませんが、プラグイン側がLanguage Serverの機能に介入できるようにした場合、例えば文書内のコードブロックに、そのコードの言語に従ったハイライトが付けられるかもしれません。
Diagnosticsの実装後、Language Serverから提供できるSyntax Highlightとしてこの機能を実装していく予定です。

=== Hover

=== Folding Range

=== その他

Language Serverによって執筆体験の向上を行うために最も必要な要素は、高度な入力補完(Completion)やInaly Hint等のアノテーションからの情報です。例えば、以下の様な記述を行いたい場合、`std.list`まで書いた時点で、`[std.list-elem ]`の入力が補完されると、執筆体験が向上すると考えられます。

```brack
{std.list
  [std.list-elem hoge1],
  [std.list-elem hoge2],
}
```
これを実現するには、「`std.list`が`std.list-elem`コマンドのみを引数に持つ」という様な、ある引数を特定のコマンドのみに限定する制約をプラグインが定め、Brackがそれに基づき検査する必要があります。
しかし、この制約は、プラグイン開発者が`std.list`の引数に別のコマンド(例えば`std.list-elem2`)も許容したい場合等を考慮すると適切な制約ではないでしょう。
そこで、この補完に近い体験を提供するために、二つの選択肢を検討しています。

その一つが、プラグインによるLanguage Serverへの介入です。あるコマンドが入力された場合や、引数が入力された場合等のいくつかのトリガーに対して、挿入・置換・削除等のBrackが用意したAPIをプラグインが呼び出すことで、入力補完を実現することができます。
また、警告を表示するアクションを用意することで、コマンドの引数が違うなどの問題が存在したときにエラー通知できます。
ただしこれらは、プラグイン開発の負担を大きくし、また、執筆体験がプラグインに応じて大きく異なってしまう可能性があります。

二つ目が、型システムによる入力補完です。
これは、コマンドを入力した時に自動で引数を補完してくれる様な強力な入力補完は実現できませんが、プラグイン開発の負担や、プラグインごとの執筆体験のばらつきといった問題を解決することができます。
ただし、これを実装するためには先に型システムの設計・実装が必要となり、開発コストがかかります。

上記の様な補完が難しい場合でも、Inaly Hintの活用によって、補完によって行いたかった執筆体験の一部を行うことができます。
Inaly Hintとは、コード上の任意の場所にアノテーションを表示できる機能であり、一般的なプログラミングにおいては、引数の型や戻り値の型のアノテーションを表示する機能として利用されます。
Brackにおいては、プラグインがコマンド引数のアノテーションをメタデータの一部としてBrackに提供することで、BrackのLanguage ServerがInaly Hintでアノテーションの表示を行うことができます。先ほどの例で言えば、`std.list`の引数に対して`list-elem`の様なアノテーションを表示すれば、執筆者は入力するべきコマンドを把握しやすくなります。

私はラボユースでの開発を通して、これらの未確定な機能の設計・実装を行い、Brackの執筆体験の向上に貢献したいと考えています。

== 計画

= 自己アピール

== 「Go言語で作るインタプリタ」のRustによる実装

== 正規表現エンジン

== 競プロ

== シフト

== ロボコン

== SATソルバー